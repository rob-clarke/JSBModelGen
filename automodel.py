import xml.dom.minidom

class Operation():
    def __init__(self,type,a,b):
        self.type = type
        self.a = a
        self.b = b
    
    def __add__(self,other):
        return Operation("sum",self,other)
    
    def __radd__(self,other):
        return Operation("sum",other,self)
    
    def __sub__(self,other):
        return Operation("difference",self,other)
    
    def __rsub__(self,other):
        return Operation("difference",other,self)
    
    def __neg__(self):
        return Operation("difference",0,self)
    
    def __mul__(self,other):
        return Operation("product",self,other)
    
    def __rmul__(self,other):
        return Operation("product",other,self)
    
    def __truediv__(self,other):
        return Operation("quotient",self,other)
    
    def __rtruediv__(self,other):
        return Operation("quotient",other,self)
    
    def __pow__(self,other):
        return Operation("pow",self,other)
    
    def __rpow__(self,other):
        return Operation("pow",other,self)
    
    def __str__(self) -> str:
        return f"{self.type}({self.a},{self.b})"

class Property(Operation):
    def __init__(self,name: str):
        self.name = name
    
    def __str__(self):
        return f"Var({self.name})"

def generate_xml(node):
    if isinstance(node,Property):
        return f"<property>{node.name}</property>"
    
    if isinstance(node,Operation):
        tag = node.type
        lhs = generate_xml(node.a)
        rhs = "" if node.b is None else generate_xml(node.b)
        return f"<{tag}>{lhs}{rhs}</{tag}>"
    
    else:
        return f"<value>{node}</value>"

def generate_aerofuncs(effect_fn):
    alpha = Property("aero/alpha-rad")
    beta = Property("aero/beta-rad")
    airspeed = Property("velocities/vtrue-fps")
    dynamic_pressure = Property("aero/qbar-psf")
    
    p = Property("velocities/p-rad_sec")
    q = Property("velocities/q-rad_sec")
    r = Property("velocities/r-rad_sec")
    
    forces,torques = effect_fn([alpha,beta,airspeed,dynamic_pressure],[p,q,r],[])
    
    def generate_axis(name,quantity):
        return f'\
            <axis name="{name}">\
                <function>\
                    {generate_xml(quantity)} \
                </function>\
            </axis>'
    
    axes = ""
    axes += generate_axis("X",forces[0])
    axes += generate_axis("Y",forces[1])
    axes += generate_axis("Z",forces[2])
    
    axes += generate_axis("ROLL",torques[0])
    axes += generate_axis("PITCH",torques[1])
    axes += generate_axis("YAW",torques[2])
    
    return axes

def generate_modelfile(effect_fn):
    input_filename = "MXS2"
    return f"""\
<?xml version="1.0"?>
<!-- =================================================================================== -->
<!-- |    This document was autogenerated by automodel from {input_filename}               | -->
<!-- |    You are welcome to attempt to edit this file by hand                         | -->
<!-- =================================================================================== -->
<?xml-stylesheet type="text/xsl" href="http://jsbsim.sourceforge.net/JSBSim.xsl"?>
<fdm_config name="{input_filename}" version="2.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://jsbsim.sourceforge.net/JSBSim.xsd"
    release="BETA"
    >
    <aerodynamics>
    {generate_aerofuncs(effect_fn)}
    </aerodynamics>
</fdm_config>
"""

if __name__ == "__main__":
    Sw = 0.263
    cw = 0.24
    S_t = 0.0825
    x_t = -0.585

    import math
    
    def exp(x):
        return Operation("exp",x,None)
    def tan(x):
        return Operation("tan",x,None)
    def sin(x):
        return Operation("sin",x,None)
    def cos(x):
        return Operation("cos",x,None)
    def atan(x):
        return Operation("atan",x,None)
    
    def H(x,p,k=10):
        return 1.0 / ( 1.0 + exp(-2*k*(x-p)) )

    def S(x,l,h,k=10):
        return H(x,l,k)*(1-H(x,h,k))

    def deg2rad(deg):
        return deg/180.0 * math.pi
    
    def c_lta(alpha):
        return 3.5810*S(alpha,-0.1745,0.1745)*alpha \
            + 0.65 * H(alpha,0.1745) \
            - 0.65 * (1-H(alpha,-0.1745))
    
    def get_effect(airstate,rates,input):
        alpha = airstate[0]
        c_l = S(alpha,-0.34,0.2719) * (0.1615 + 5.2212*alpha)
                
        a_lim = deg2rad(30)
        c_d = S(alpha,-a_lim,a_lim)*(2.3814*(alpha-0.0207)**2+0.0671) + 2*(1-S(alpha,-a_lim,a_lim))
        
        a_lim = deg2rad(15)
        c_m = S(alpha,-a_lim,a_lim,12) * (-0.5462 * tan(1.4151*(alpha-0.0484)) + 0.053) \
            + 0.5 * (1-H(alpha,-a_lim,12)) - 0.5 * H(alpha,a_lim,12)
        
        q = airstate[3]
        V = airstate[2]
        
        alpha_q = atan( (-rates[1]*x_t + V*sin(alpha)) / (V*cos(alpha)) )
        m_t_aq = x_t * q * S_t * (c_lta(alpha_q) - c_lta(alpha))
        
        lift = q * Sw * c_l
        drag = q * Sw * c_d
        moment = q * Sw * cw * c_m + m_t_aq
        
        # print(f"Alpha: {alpha:.3f}, q: {q:.3f},  c_m: {c_m:.3f}, alpha_q: {alpha_q:.3f}, moment: {moment:.3f}")
        
        return ([-drag,0,-lift],[0,moment,0])
    
    print(xml.dom.minidom.parseString(generate_modelfile(get_effect)).toprettyxml())